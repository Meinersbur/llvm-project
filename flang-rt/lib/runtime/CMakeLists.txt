#===-- lib/runtime/CMakeLists.txt ------------------------------------------===#
#
# Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
# See https://llvm.org/LICENSE.txt for license information.
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
#
#===------------------------------------------------------------------------===#

include(AddFlangRTOffload)
# function checks

set(Backtrace_LIBRARY "")
find_package(Backtrace)
set(HAVE_BACKTRACE ${Backtrace_FOUND})
set(BACKTRACE_HEADER ${Backtrace_HEADER})

include(CheckFortranSourceCompiles)
include(CMakePushCheckState)

cmake_push_check_state(RESET)
set(CMAKE_REQUIRED_FLAGS "-ffree-form")
check_fortran_source_compiles([[
    program quadmath
      real(16) :: var1
      print *, 'Hello'
    end
  ]]
  FORTRAN_SUPPORTS_REAL16
)
cmake_pop_check_state()

message("FORTRAN_SUPPORTS_REAL16: ${FORTRAN_SUPPORTS_REAL16}")
if (FORTRAN_SUPPORTS_REAL16)
  add_compile_definitions(FLANG_SUPPORT_R16=1)
  #add_compile_options(-DFLANG_SUPPORT_R16=2)
  add_compile_options($<$<COMPILE_LANGUAGE:Fortran>:-cpp>)
endif ()

# List of files that are buildable for all devices.
set(supported_sources
  ${FLANG_SOURCE_DIR}/lib/Decimal/binary-to-decimal.cpp
  ${FLANG_SOURCE_DIR}/lib/Decimal/decimal-to-binary.cpp
  ISO_Fortran_binding.cpp
  allocator-registry.cpp
  allocatable.cpp
  array-constructor.cpp
  assign.cpp
  buffer.cpp
  character.cpp
  connection.cpp
  copy.cpp
  derived-api.cpp
  derived.cpp
  descriptor-io.cpp
  descriptor.cpp
  dot-product.cpp
  edit-input.cpp
  edit-output.cpp
  environment.cpp
  external-unit.cpp
  extrema.cpp
  file.cpp
  findloc.cpp
  format.cpp
  inquiry.cpp
  internal-unit.cpp
  io-api.cpp
  io-api-minimal.cpp
  io-error.cpp
  io-stmt.cpp
  iostat.cpp
  matmul-transpose.cpp
  matmul.cpp
  memory.cpp
  misc-intrinsic.cpp
  namelist.cpp
  non-tbp-dio.cpp
  numeric.cpp
  pointer.cpp
  product.cpp
  pseudo-unit.cpp
  ragged.cpp
  stat.cpp
  stop.cpp
  sum.cpp
  support.cpp
  terminator.cpp
  tools.cpp
  transformational.cpp
  type-code.cpp
  type-info.cpp
  unit.cpp
  utf.cpp
)

# List of source not used for GPU offloading.
set(CMAKE_Fortran_MODULE_DIRECTORY "${LLVM_LIBRARY_OUTPUT_INTDIR}/../include/flang")
set(host_sources
  __fortran_ieee_exceptions.f90
  __fortran_type_info.f90
  ieee_arithmetic.f90
  ieee_exceptions.f90
  ieee_features.f90
  iso_c_binding.f90
  iso_fortran_env_impl.f90
  iso_fortran_env.f90

  command.cpp
  complex-powi.cpp
  complex-reduction.c
  exceptions.cpp
  execute.cpp
  extensions.cpp
  main.cpp
  random.cpp
  reduce.cpp
  reduction.cpp
  stop.cpp
  temporary-stack.cpp
  time-intrinsic.cpp
  unit-map.cpp
)

# Module sources that are required by other modules
# Workaround for CMAKE_Fortran_BUILDING_INTRINSIC_MODULES not working with Ninja
set(intrinsics_sources
  __fortran_builtins.f90
)


#set_property(SOURCE "__fortran_type_info.f90" APPEND PROPERTY OBJECT_DEPENDS  "/home/meinersbur/build/llvm-project-flangrt/release_bootstrap/llvm_flang_runtimes/./lib/../include/flang/__fortran_builtins.mod")
#set_property(SOURCE "__fortran_type_info.f90" APPEND PROPERTY OBJECT_DEPENDS  "flang-rt/lib/runtime/CMakeFiles/flang_rt.runtime.static.dir/__fortran_builtins.f90.o")
#set_property(SOURCE "__fortran_type_info.f90" APPEND PROPERTY OBJECT_DEPENDS  "/home/meinersbur/build/llvm-project-flangrt/release_bootstrap/llvm_flang_runtimes/./lib/../include/flang/__fortran_builtins.mod")

message("CMAKE_SYSTEM_PROCESSOR: ${CMAKE_SYSTEM_PROCESSOR}")
message("CMAKE_HOST_SYSTEM_PROCESSOR: ${CMAKE_HOST_SYSTEM_PROCESSOR}")
if (CMAKE_SYSTEM_PROCESSOR STREQUAL "powerpc")
  list(APPEND host_source
    __ppc_types.f90
    __ppc_intrinsics.f90
    mma.f90
  )
endif ()



#if (FLANG_RT_EXPERIMENTAL_OFFLOAD_SUPPORT STREQUAL "CUDA")
  list(APPEND supported_sources
    __cuda_builtins.f90
    __cuda_device.f90
    cudadevice.f90
  )

# FIXME: Has CMake support for CUDA-Fortran?
# FIXME: __cuda_builtins.f90 does not need -xcuda?
set_source_files_properties(
    __cuda_device.f90
    cudadevice.f90
  PROPERTIES
    COMPILE_OPTIONS "-xcuda" # TODO: append
)
#endif ()



# Flang is not always able to consume its own preprocessor output.
# CMake's module dependency parser assumes input without preprocessor directives, not preprocessing them therefore risks missing dependencies.
set_source_files_properties(
  #mma.f90
  #cudadevice.f90
 # ieee_arithmetic.f90 # See https://github.com/llvm/llvm-project/issues/139297
  PROPERTIES
    Fortran_PREPROCESS OFF
  #  COMPILE_OPTIONS "-cpp" # TODO: append
)

# Sources that can be compiled directly for the GPU.
set(gpu_sources
  ${FLANG_SOURCE_DIR}/lib/Decimal/binary-to-decimal.cpp
  ${FLANG_SOURCE_DIR}/lib/Decimal/decimal-to-binary.cpp
  ISO_Fortran_binding.cpp
  allocator-registry.cpp
  allocatable.cpp
  array-constructor.cpp
  assign.cpp
  buffer.cpp
  character.cpp
  connection.cpp
  copy.cpp
  derived-api.cpp
  derived.cpp
  dot-product.cpp
  edit-output.cpp
  extrema.cpp
  findloc.cpp
  format.cpp
  inquiry.cpp
  internal-unit.cpp
  io-error.cpp
  iostat.cpp
  matmul-transpose.cpp
  matmul.cpp
  memory.cpp
  misc-intrinsic.cpp
  non-tbp-dio.cpp
  numeric.cpp
  pointer.cpp
  product.cpp
  ragged.cpp
  stat.cpp
  sum.cpp
  support.cpp
  terminator.cpp
  tools.cpp
  transformational.cpp
  type-code.cpp
  type-info.cpp
  utf.cpp
  complex-powi.cpp
  reduce.cpp
  reduction.cpp
  temporary-stack.cpp
)




add_compile_options($<$<COMPILE_LANGUAGE:Fortran>:SHELL:-mmlir> $<$<COMPILE_LANGUAGE:Fortran>:-ignore-missing-type-desc>)

# Flang bug: Reformatting of cooked token buffer causes identifier to be split between lines
add_compile_options($<$<COMPILE_LANGUAGE:Fortran>:SHELL:-Xflang> $<$<COMPILE_LANGUAGE:Fortran>:-fno-reformat>)

#add_compile_options($<$<COMPILE_LANGUAGE:Fortran>:-mllvm=-flang-intrinsics-mode>)
#set(CMAKE_Fortran_PREPROCESS FALSE)
#add_compile_options(-mllvm -ignore-missing-type-desc)

set(CMAKE_Fortran_BUILDING_INTRINSIC_MODULES TRUE)
set(CMAKE_Fortran_BUILDING_INSTRINSIC_MODULES TRUE)

file(GLOB_RECURSE public_headers
  "${FLANG_RT_SOURCE_DIR}/include/flang_rt/*.h"
  "${FLANG_SOURCE_DIR}/include/flang/Common/*.h"
  )

file(GLOB_RECURSE private_headers
  "${FLANG_RT_SOURCE_DIR}/lib/flang_rt/*.h"
  "${FLANG_SOURCE_DIR}/lib/Common/*.h"
  )


# Import changes from flang_rt.quadmath
get_target_property(f128_sources
  FortranFloat128MathILib INTERFACE_SOURCES
  )
if (f128_sources)
  # The interface may define special macros for Float128Math files,
  # so we need to propagate them.
  get_target_property(f128_defs
    FortranFloat128MathILib INTERFACE_COMPILE_DEFINITIONS
    )
  set_property(SOURCE ${f128_sources}
    APPEND PROPERTY COMPILE_DEFINITIONS
    ${f128_defs}
    )
  get_target_property(f128_include_dirs
    FortranFloat128MathILib INTERFACE_INCLUDE_DIRECTORIES
    )
  set_property(SOURCE ${f128_sources}
    APPEND PROPERTY INCLUDE_DIRECTORIES
    ${f128_include_dirs}
    )
else ()
  set(f128_sources "")
endif ()

if ("${LLVM_RUNTIMES_TARGET}" MATCHES "^amdgcn|^nvptx")
  set(sources ${gpu_sources})
else ()
  set(sources ${supported_sources} ${host_sources} ${f128_sources})
endif ()


# Stop CMake from ignoring dependencies between builtin-modules. CMake added this feature for (classic) Flang.
# Two spellings for the same thing: https://cmake.org/cmake/help/latest/prop_tgt/Fortran_BUILDING_INSTRINSIC_MODULES.html
set(Fortran_BUILDING_INTRINSIC_MODULES TRUE)
set(Fortran_BUILDING_INSTRINSIC_MODULES TRUE)



#add_compile_options($<$<COMPILE_LANGUAGE:Fortran>:SHELL:-module-dir> $<$<COMPILE_LANGUAGE:Fortran>:"${FLANG_RT_OUTPUT_RESOURCE_MOD_DIR}">)
add_compile_options($<$<COMPILE_LANGUAGE:Fortran>:SHELL:"-fintrinsic-modules-path"> $<$<COMPILE_LANGUAGE:Fortran>:"${FLANG_RT_OUTPUT_RESOURCE_MOD_DIR}">)




if (NOT WIN32)
  # Not a real library
  add_flangrt_library(flang_rt.intrinsics OBJECT
    ${intrinsics_sources}
  )

  add_flangrt_library(flang_rt.runtime STATIC SHARED
    ${sources}
  #  $<TARGET_OBJECTS:flang_rt.intrinsics>
    LINK_LIBRARIES ${Backtrace_LIBRARY}
    INSTALL_WITH_TOOLCHAIN
    ADDITIONAL_HEADERS ${public_headers} ${private_headers}
    LINK_LIBRARIES flang_rt.intrinsics
    TARGET_PROPERTIES
      # Two spellings for the same thing: https://cmake.org/cmake/help/latest/prop_tgt/Fortran_BUILDING_INSTRINSIC_MODULES.html
      # Supported only since CMake 3.22
      Fortran_BUILDING_INTRINSIC_MODULES TRUE
      Fortran_BUILDING_INSTRINSIC_MODULES TRUE
  )
# TODO: shared (or global)
    target_compile_options(flang_rt.runtime.static PRIVATE "$<$<COMPILE_LANGUAGE:Fortran>:SHELL:-fintrinsic-modules-path>" "$<$<COMPILE_LANGUAGE:Fortran>:${FLANG_RT_OUTPUT_RESOURCE_MOD_DIR}>")

  enable_cuda_compilation(flang_rt.runtime "${supported_sources}")
  enable_omp_offload_compilation(flang_rt.runtime "${supported_sources}")

  # Select a default runtime, which is used for unit and regression tests.
  get_target_property(default_target flang_rt.runtime.default ALIASED_TARGET)
  add_library(flang_rt.runtime.unittest ALIAS "${default_target}")
else()
  # Target for building all versions of the runtime
  add_custom_target(flang_rt.runtime)
  set_target_properties(flang_rt.runtime PROPERTIES FOLDER "Flang-RT/Meta")

  function (add_win_flangrt_runtime libtype suffix msvc_lib)
    set(name "flang_rt.runtime.${suffix}")
    message("${name}.intrinsics")
    add_flangrt_library(${name}.intrinsics OBJECT
      ${intrinsics_sources}
    )

     # set_target_properties(${name}.intrinsics
     #  PROPERTIES
     #     Fortran_MODULE_DIRECTORY "${FLANG_RT_OUTPUT_RESOURCE_MOD_DIR}"
     #   )

    #include_directories("${CMAKE_CURRENT_BINARY_DIR}/module.${suffix}")
    add_flangrt_library(${name} ${libtype}
        ${sources} $<TARGET_OBJECTS:${name}.intrinsics>
        ${ARGN}
        LINK_LIBRARIES ${name}.intrinsics ${Backtrace_LIBRARY}
        ADDITIONAL_HEADERS ${public_headers} ${private_headers}
        TARGET_PROPERTIES
          Fortran_BUILDING_INTRINSIC_MODULES TRUE
          Fortran_BUILDING_INSTRINSIC_MODULES TRUE
      )

# "$<$<COMPILE_LANGUAGE:Fortran>:-Xflang>"
#TODO: Better as -fintrinsic-modules-path, need added option
    target_compile_options(${name} PRIVATE "$<$<COMPILE_LANGUAGE:Fortran>:SHELL:-fintrinsic-modules-path>" "$<$<COMPILE_LANGUAGE:Fortran>:${CMAKE_CURRENT_BINARY_DIR}/module.${suffix}>")
    target_compile_options(${name}.intrinsics PRIVATE "$<$<COMPILE_LANGUAGE:Fortran>:SHELL:-fintrinsic-modules-path>" "$<$<COMPILE_LANGUAGE:Fortran>:${CMAKE_CURRENT_BINARY_DIR}/module.${suffix}>")
    target_compile_options(${name} PRIVATE "$<$<COMPILE_LANGUAGE:Fortran>:SHELL:-fintrinsic-modules-path>" "$<$<COMPILE_LANGUAGE:Fortran>:${FLANG_RT_OUTPUT_RESOURCE_MOD_DIR}>")

    if (msvc_lib)
      set_target_properties(${name}
          PROPERTIES
            MSVC_RUNTIME_LIBRARY "${msvc_lib}"
        )
    endif ()

    # Setting an unique Fortran_MODULE_DIRECTORY is required for each variant to
    # write a different .mod file.
    # Except for one selected one (the first)
    if (_has_main_intrinsics)
        set_property(TARGET ${name} ${name}.intrinsics
          PROPERTY   Fortran_MODULE_DIRECTORY "module.${suffix}"
        )
   else ()
        set(_has_main_intrinsics "YES" PARENT_SCOPE)
   endif ()



    enable_cuda_compilation(${name} "${supported_sources}")
    enable_omp_offload_compilation(${name} "${supported_sources}")
    add_dependencies(flang_rt.runtime ${name})
  endfunction ()

  # Variants of the static flang_rt for different versions of the msvc runtime.
  #
  # The dynamic/dynamic_dbg variants are not DLLs themselves, only require
  # linking to msvcrt(d).dll.
  # FIXME: Generating actual runtime DLLs is currently not possible. There are
  # two roadblocks:
  #
  #  * Flang emits /DEFAULTLIB:flang_rt.dynamic.lib into
  #    iso_fortran_env_impl.f90.obj. Because that file is itself part of
  #    flang_rt.dynamic, this results in a recursive dependency when invoking
  #    the linker.
  #
  #  * The externally-visible functions must either be annotated with
  #    __declspec(dllexport), or listed in an exports file. A possible workaround
  #    is CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS which would also export the internal
  #    C++ symbols and still requires global data symbols to be annotated
  #    manually.
  add_win_flangrt_runtime(STATIC static      MultiThreaded         INSTALL_WITH_TOOLCHAIN)
  add_win_flangrt_runtime(STATIC dynamic     MultiThreadedDLL      INSTALL_WITH_TOOLCHAIN)
  add_win_flangrt_runtime(STATIC static_dbg  MultiThreadedDebug    INSTALL_WITH_TOOLCHAIN)
  add_win_flangrt_runtime(STATIC dynamic_dbg MultiThreadedDebugDLL INSTALL_WITH_TOOLCHAIN)

  # Unittests link against LLVMSupport which is using CMake's default runtime
  # library selection, which is either MultiThreadedDLL or MultiThreadedDebugDLL
  # depending on the configuration. They have to match or linking will fail.
  if (GENERATOR_IS_MULTI_CONFIG)
    # We cannot select an ALIAS library because it may be different
    # per configuration. Fallback to CMake's default.
    add_win_flangrt_runtime(STATIC unittest "" EXCLUDE_FROM_ALL)
  else ()
    string(TOLOWER ${CMAKE_BUILD_TYPE} build_type)
    if (build_type STREQUAL "debug")
      add_library(flang_rt.runtime.unittest ALIAS flang_rt.runtime.dynamic_dbg)
    else ()
      add_library(flang_rt.runtime.unittest ALIAS flang_rt.runtime.dynamic)
    endif ()
  endif ()
endif()
